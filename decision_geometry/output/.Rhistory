arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 33
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 36
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 26
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 40
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output")
dir <- getwd()
## Set parameters
N <- 4
## Derive variable values
bifurcation_angle <- 80*pi/180
post1_x <- 5*cos(pi/6); post1_y <- 5*sin(pi/6)
post2_x <- 5*cos(-pi/6); post2_y <- 5*sin(-pi/6)
bifurcation_x <- post1_y/tan(-bifurcation_angle/2)+post1_x; bifurcation_y <- 0
c1_x <- (post1_x + bifurcation_x)/2; c1_y <- (post1_y + bifurcation_y)/2
c2_x <- (post2_x + bifurcation_x)/2; c2_y <- (post2_y + bifurcation_y)/2
m1 <- (bifurcation_y-post1_y)/(bifurcation_x-post1_x)
m2 <- (bifurcation_y-post2_y)/(bifurcation_x-post2_x)
x0 <- c1_x + m1*c1_y - m1*(c1_x - c2_x + m1*c1_y - m2*c2_y)/(m1 - m2)
y0 <- (c1_x - c2_x + m1*c1_y - m2*c2_y)/(m1 - m2)
## Load data
df <- read.csv("geometry.csv")
df$x <- df$x/100
df$y <- df$y/100
x <- as.data.frame(melt(tapply(df$x, df$sim_id, mean)))
y <- as.data.frame(melt(tapply(df$y-5, df$sim_id, mean)))
dir_x <- as.data.frame(melt(tapply(df$dir_x, df$sim_id, mean)))
dir_y <- as.data.frame(melt(tapply(df$dir_y, df$sim_id, mean)))
names(x) <- c('sim_id', 'x')
names(y) <- c('sim_id', 'y')
names(dir_x) <- c('sim_id', 'dir_x')
names(dir_y) <- c('sim_id', 'dir_y')
pos <- merge(x,y)
dir <- merge(dir_x,dir_y)
df <- merge(pos,dir)
df$`vector length` <- sqrt(df$dir_x^2+df$dir_y^2)
head(df)
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
xlim(0,4.35) + coord_fixed(ratio = 1) + scale_fill_viridis_c() +
guides(fill = FALSE) + theme_cus()
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(10,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
xlim(0,4.35) + coord_fixed(ratio = 1) + scale_fill_viridis_c() +
guides(fill = FALSE) + theme_cus()
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(2,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,2,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
xlim(0,4.35) + coord_fixed(ratio = 1) + scale_fill_viridis_c() +
guides(fill = FALSE) + theme_cus()
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
xlim(0,4.35) + coord_fixed(ratio = 1) + scale_fill_viridis_c(expand = c(0,0)) +
guides(fill = FALSE) + theme_cus()
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
xlim(0,4.35) + coord_fixed(ratio = 1) + scale_fill_viridis_c() +
scale_x_continuous(expand = c(0,0)) +
guides(fill = FALSE) + theme_cus()
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
xlim(0,4.35) + coord_fixed(ratio = 1) + scale_fill_viridis_c() +
scale_y_continuous(expand = c(0,0)) +
guides(fill = FALSE) + theme_cus()
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
scale_x_continuous(limits = c(0,4.35), expand = c(0,0)) + coord_fixed(ratio = 1) + scale_fill_viridis_c() +
guides(fill = FALSE) + theme_cus()
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
scale_x_continuous(limits = c(0,4.35), expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
coord_fixed(ratio = 1) + scale_fill_viridis_c() + guides(fill = FALSE) +
theme_cus()
ggsave('/Users/vivekhsridhar/Documents/Work/Ideas/Decision\ Geometry/Figures/McDonnell\ proposal/geometry.png',
width = 4.33, height = 5, dpi = 300)
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
scale_x_continuous(limits = c(0,4.35), expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
coord_fixed(ratio = 1) + scale_fill_viridis_c() + guides(fill = FALSE) +
xlab("") + ylab("") + theme_cus()
ggsave('/Users/vivekhsridhar/Documents/Work/Ideas/Decision\ Geometry/Figures/McDonnell\ proposal/geometry.png',
width = 4.33, height = 5, dpi = 300)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.marg
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output")
dir <- getwd()
## Set parameters
N <- 4
## Derive variable values
bifurcation_angle <- 81.05*pi/180
post1_x <- 5*cos(pi/6); post1_y <- 5*sin(pi/6)
post2_x <- 5*cos(-pi/6); post2_y <- 5*sin(-pi/6)
bifurcation_x <- post1_y/tan(-bifurcation_angle/2)+post1_x; bifurcation_y <- 0
c1_x <- (post1_x + bifurcation_x)/2; c1_y <- (post1_y + bifurcation_y)/2
c2_x <- (post2_x + bifurcation_x)/2; c2_y <- (post2_y + bifurcation_y)/2
m1 <- (bifurcation_y-post1_y)/(bifurcation_x-post1_x)
m2 <- (bifurcation_y-post2_y)/(bifurcation_x-post2_x)
x0 <- c1_x + m1*c1_y - m1*(c1_x - c2_x + m1*c1_y - m2*c2_y)/(m1 - m2)
y0 <- (c1_x - c2_x + m1*c1_y - m2*c2_y)/(m1 - m2)
## Load data
df <- read.csv("geometry.csv")
df$x <- df$x/100
df$y <- df$y/100
x <- as.data.frame(melt(tapply(df$x, df$sim_id, mean)))
y <- as.data.frame(melt(tapply(df$y-5, df$sim_id, mean)))
dir_x <- as.data.frame(melt(tapply(df$dir_x, df$sim_id, mean)))
dir_y <- as.data.frame(melt(tapply(df$dir_y, df$sim_id, mean)))
names(x) <- c('sim_id', 'x')
names(y) <- c('sim_id', 'y')
names(dir_x) <- c('sim_id', 'dir_x')
names(dir_y) <- c('sim_id', 'dir_y')
pos <- merge(x,y)
dir <- merge(dir_x,dir_y)
df <- merge(pos,dir)
df$`vector length` <- sqrt(df$dir_x^2+df$dir_y^2)
head(df)
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
scale_x_continuous(limits = c(0,4.35), expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
coord_fixed(ratio = 1) + scale_fill_viridis_c() + guides(fill = FALSE) +
xlab("") + ylab("") + theme_cus()
ggsave('/Users/vivekhsridhar/Documents/Work/Ideas/Decision\ Geometry/Figures/McDonnell\ proposal/geometry.png',
width = 4.33, height = 5, dpi = 300)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output")
dir <- getwd()
## Set parameters
N <- 4
## Derive variable values
bifurcation_angle <- 81.05*pi/180
post1_x <- 5*cos(pi/6); post1_y <- 5*sin(pi/6)
post2_x <- 5*cos(-pi/6); post2_y <- 5*sin(-pi/6)
bifurcation_x <- post1_y/tan(-bifurcation_angle/2)+post1_x; bifurcation_y <- 0
c1_x <- (post1_x + bifurcation_x)/2; c1_y <- (post1_y + bifurcation_y)/2
c2_x <- (post2_x + bifurcation_x)/2; c2_y <- (post2_y + bifurcation_y)/2
m1 <- (bifurcation_y-post1_y)/(bifurcation_x-post1_x)
m2 <- (bifurcation_y-post2_y)/(bifurcation_x-post2_x)
x0 <- c1_x + m1*c1_y - m1*(c1_x - c2_x + m1*c1_y - m2*c2_y)/(m1 - m2)
y0 <- (c1_x - c2_x + m1*c1_y - m2*c2_y)/(m1 - m2)
## Load data
df <- read.csv("geometry.csv")
df$x <- df$x/100
df$y <- df$y/100
x <- as.data.frame(melt(tapply(df$x, df$sim_id, mean)))
y <- as.data.frame(melt(tapply(df$y-5, df$sim_id, mean)))
dir_x <- as.data.frame(melt(tapply(df$dir_x, df$sim_id, mean)))
dir_y <- as.data.frame(melt(tapply(df$dir_y, df$sim_id, mean)))
names(x) <- c('sim_id', 'x')
names(y) <- c('sim_id', 'y')
names(dir_x) <- c('sim_id', 'dir_x')
names(dir_y) <- c('sim_id', 'dir_y')
pos <- merge(x,y)
dir <- merge(dir_x,dir_y)
df <- merge(pos,dir)
df$`vector length` <- sqrt(df$dir_x^2+df$dir_y^2)
head(df)
ggplot(df, aes(x = x, y = y)) +
geom_raster(aes(fill = `vector length`)) + geom_hline(yintercept = 0, lty = 'dashed') +
geom_ellipse(aes(x0 = x0, y0 = y0, a = x0-bifurcation_x, b = x0-bifurcation_x, angle = 0), lty='dotted') +
scale_x_continuous(limits = c(0,4.35), expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
coord_fixed(ratio = 1) + scale_fill_viridis_c() + guides(fill = FALSE) +
xlab("") + ylab("") + theme_cus()
ggsave('/Users/vivekhsridhar/Documents/Work/Ideas/Decision\ Geometry/Figures/McDonnell\ proposal/geometry.png',
width = 4.33, height = 5, dpi = 300)
