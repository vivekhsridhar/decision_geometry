source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 36
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 26
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 40
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
v_colours <- c( `red` = "#d11141", `green` = "#00b159", `blue` = "#00aedb", `orange` = "#f37735",
`yellow` = "#ffc425", `light grey` = "#cccccc", `dark grey` = "#8c8c8c",
`lime green` = "#74bd4a", `purple` = "#583390")
v_cols <- function(...) {
cols <- c(...)
if (is.null(cols))
return (v_colours)
v_colours[cols]
}
v_palettes <- list(
`main`  = v_cols("blue", "green", "yellow"),
`cool`  = v_cols("blue", "green"),
`hot`   = v_cols("yellow", "orange", "red"),
`mixed` = v_cols("blue", "green", "yellow", "orange", "red"),
`asymmetric` = v_cols("purple", "lime green", "yellow"),
`grey`  = v_cols("light grey", "dark grey")
)
v_pal <- function(palette = "main", reverse = FALSE, ...) {
pal <- v_palettes[[palette]]
if (reverse) pal <- rev(pal)
colorRampPalette(pal, ...)
}
scale_colour_viv <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
pal <- v_pal(palette = palette, reverse = reverse)
if (discrete) {
discrete_scale("colour", paste0("drsimonj_", palette), palette = pal, ...)
} else {
scale_color_gradientn(colours = pal(256), ...)
}
}
scale_fill_viv <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
pal <- v_pal(palette = palette, reverse = reverse)
if (discrete) {
discrete_scale("fill", paste0("drsimonj_", palette), palette = pal, ...)
} else {
scale_fill_gradientn(colours = pal(256), ...)
}
}
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Work/Results/decision_geometry/Data/Theory/NN/hat_model/")
dir <- getwd()
## Set parameters
size <- '60'
angle <- '80'
start <- 0
end <- 2
for (d in start:end) {
if (d == 0) bias <- FALSE
else {
bias <- TRUE
if (d == 1) centre <- FALSE
else centre <- TRUE
}
suffix <- '_no_bias'
if (bias) {
if (centre) suffix <- '_bias_c'
else suffix <- '_bias_s'
}
## Load data
df <- read.csv(paste0('pscan_n', size, '_a', angle, suffix, '.csv'))
head(df)
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
if (bias) {
if (centre) p_target <- (length(which(tmp$target_reached == 1))) / dim(tmp)[1]
else p_target <- (length(which(tmp$target_reached == 0))) / dim(tmp)[1]
} else p_target <- (length(which(tmp$target_reached == 0)) + length(which(tmp$target_reached == 2))) / (2*dim(tmp)[1])
path_length <- median(tmp$path_length)
#pl_l <- quantile(tmp$path_length, 0.25)
#pl_u <- quantile(tmp$path_length, 0.75)
trial_time <- median(tmp$trial_time)
#tt_l <- quantile(tmp$trial_time, 0.25)
#tt_u <- quantile(tmp$trial_time, 0.75)
tmp <- as.data.frame(cbind(d, i, j, p_target, path_length, trial_time))
if (d == start & i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
}
names(data) <- c("idx", "temperature", "h", "p_target", "path_length", "trial_time")
data2 <- data[which(data$temperature == 0.02),]
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output/")
dir <- getwd()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.1) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.1) + theme_cus()
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output/")
dir <- getwd()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c() + theme_cus()
i=0.02
j=0.25
j=0.26
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
tmp
View(tmp)
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c() + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c() + theme_cus()
ggplot(data, aes(x = temperature, y = h, fill = trial_time)) + geom_tile() +
scale_fill_viridis_c() + theme_cus()
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=(0,1)) + theme_cus()
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=(0,1)) + theme_cus()
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=c(0,1)) + theme_cus()
summary(data)
hist(data$accuracy)
hist(data$accuracy, breaks = 10)
hist(data$accuracy, breaks = 50)
hist(df$preferred_target)
hist(df$reached_target)
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=c(0,1)) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=c(0,1)) + theme_cus()
ggplot(data, aes(x = temperature, y = h, fill = trial_time)) + geom_tile() +
scale_fill_viridis_c() + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=c(0,1)) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
df$correct <- 0
df$correct[which(df$preferred_target == df$reached_target)] <- 1
for (i in unique(df$temperature)) {
for (j in unique(df$h)) {
tmp <- df[which(df$temperature == i & df$h == j),]
accuracy <- sum(tmp$correct) / dim(tmp)[1]
path_length <- median(tmp$path_length)
trial_time <- median(tmp$trial_time)
tmp <- as.data.frame(cbind(i, j, accuracy, path_length, trial_time))
if (i == unique(df$temperature)[1] & j == unique(df$h)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "h", "accuracy", "path_length", "trial_time")
ggplot(data, aes(x = temperature, y = h, fill = accuracy)) + geom_tile() +
scale_fill_viridis_c(limits=c(0,1)) + theme_cus()
ggplot(data, aes(x = temperature, y = h, fill = trial_time)) + geom_tile() +
scale_fill_viridis_c() + theme_cus()
