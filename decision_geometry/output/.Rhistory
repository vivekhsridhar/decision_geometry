vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
rm(list = ls())
library(viridis)
library(reshape2)
library(ggplot2)
load('~/Dropbox/SHARED_Project_Collective decision updating/Data/sheep_group_events_all.RData')
load('~/Dropbox/SHARED_Project_Collective decision updating/Data/sheep_xy_interpolated.RData')
events.group.all <- events.group.all[order(events.group.all$t.start),]
events <- events.group.all[which(events.group.all$leave.patch.ID==11  & events.group.all$arrive.patch.ID %in% c(1,2,3,4,5)),]
event.id <- 34
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 33
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 36
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 26
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 40
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
v_colours <- c( `red` = "#d11141", `green` = "#00b159", `blue` = "#00aedb", `orange` = "#f37735",
`yellow` = "#ffc425", `light grey` = "#cccccc", `dark grey` = "#8c8c8c")
v_cols <- function(...) {
cols <- c(...)
if (is.null(cols))
return (v_colours)
v_colours[cols]
}
v_palettes <- list(
`main`  = v_cols("blue", "green", "yellow"),
`cool`  = v_cols("blue", "green"),
`hot`   = v_cols("yellow", "orange", "red"),
`mixed` = v_cols("blue", "green", "yellow", "orange", "red"),
`asymmetric` = v_cols("red", "green", "blue"),
`grey`  = v_cols("light grey", "dark grey")
)
v_pal <- function(palette = "main", reverse = FALSE, ...) {
pal <- v_palettes[[palette]]
if (reverse) pal <- rev(pal)
colorRampPalette(pal, ...)
}
scale_colour_viv <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
pal <- v_pal(palette = palette, reverse = reverse)
if (discrete) {
discrete_scale("colour", paste0("drsimonj_", palette), palette = pal, ...)
} else {
scale_color_gradientn(colours = pal(256), ...)
}
}
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Work/Results/decision_geometry/Data/Theory/NN/nu_model/")
dir <- getwd()
## Set parameters
size <- '60'
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output/")
dir <- getwd()
for (d in 0) {
if (d == 0) bias <- FALSE
else {
bias <- TRUE
if (d == 1) centre <- FALSE
else centre <- TRUE
}
suffix <- '_no_bias'
if (bias) {
if (centre) suffix <- '_bias_c'
else suffix <- '_bias_s'
}
## Load data
df <- read.csv(paste0('parameters_n', size, suffix, '.csv'))
head(df)
for (i in unique(df$temperature)) {
for (j in unique(df$nu)) {
tmp <- df[which(df$temperature == i & df$nu == j),]
if (bias) {
if (centre) p_target <- (length(which(tmp$target_reached == 1))) / dim(tmp)[1]
else p_target <- (length(which(tmp$target_reached == 0))) / dim(tmp)[1]
} else p_target <- (length(which(tmp$target_reached == 0)) + length(which(tmp$target_reached == 2))) / (2*dim(tmp)[1])
path_length <- median(tmp$path_length)
pl_l <- quantile(tmp$path_length, 0.25)
pl_u <- quantile(tmp$path_length, 0.75)
trial_time <- median(tmp$trial_time)
tt_l <- quantile(tmp$trial_time, 0.25)
tt_u <- quantile(tmp$trial_time, 0.75)
tmp <- as.data.frame(cbind(d, i, j, p_target, path_length, pl_l, pl_u, trial_time, tt_l, tt_u))
if (d == 0 & i == unique(df$temperature)[1] & j == unique(df$nu)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
}
names(data) <- c("idx", "temperature", "nu", "p_target")#, "path_length", "pl_l", "pl_u", "trial_time", "tt_l", "tt_u")
data <- data[which(data$nu %% 0.04 == 0),]
data2 <- data[which(data$temperature == 0.02),]
ggplot(data2, aes(x = nu, y = p_target, colour = as.factor(idx))) + geom_path(size = 3, lineend = 'round') +
geom_vline(aes(xintercept = 0.54), colour = 'black') + guides(colour = FALSE) +
geom_hline(aes(yintercept = 0.33), colour = 'black', linetype = 'dashed') +
scale_colour_viv(discrete = TRUE, palette = 'asymmetric') +
xlab("Nu") + ylab("P(reaching the correct target)") + theme_cus()
ggplot(data2, aes(x = nu, y = path_length)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = pl_l, ymax = pl_u), alpha = 0.2) +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
ggplot(data2, aes(x = nu, y = trial_time)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = tt_l, ymax = tt_u), alpha = 0.2) +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
## Load data
df <- read.csv(paste0('parameters_n', size, suffix, '.csv'))
head(df)
for (i in unique(df$temperature)) {
for (j in unique(df$nu)) {
tmp <- df[which(df$temperature == i & df$nu == j),]
if (bias) {
if (centre) p_target <- (length(which(tmp$target_reached == 1))) / dim(tmp)[1]
else p_target <- (length(which(tmp$target_reached == 0))) / dim(tmp)[1]
} else p_target <- (length(which(tmp$target_reached == 0)) + length(which(tmp$target_reached == 2))) / (2*dim(tmp)[1])
path_length <- median(tmp$path_length)
pl_l <- quantile(tmp$path_length, 0.25)
pl_u <- quantile(tmp$path_length, 0.75)
trial_time <- median(tmp$trial_time)
tt_l <- quantile(tmp$trial_time, 0.25)
tt_u <- quantile(tmp$trial_time, 0.75)
tmp <- as.data.frame(cbind(d, i, j, p_target, path_length, pl_l, pl_u, trial_time, tt_l, tt_u))
if (d == 0 & i == unique(df$temperature)[1] & j == unique(df$nu)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
tmp <- df[which(df$temperature == i & df$nu == j),]
if (bias) {
if (centre) p_target <- (length(which(tmp$target_reached == 1))) / dim(tmp)[1]
else p_target <- (length(which(tmp$target_reached == 0))) / dim(tmp)[1]
} else p_target <- (length(which(tmp$target_reached == 0)) + length(which(tmp$target_reached == 2))) / (2*dim(tmp)[1])
path_length <- median(tmp$path_length)
pl_l <- quantile(tmp$path_length, 0.25)
pl_u <- quantile(tmp$path_length, 0.75)
trial_time <- median(tmp$trial_time)
tt_l <- quantile(tmp$trial_time, 0.25)
tt_u <- quantile(tmp$trial_time, 0.75)
tmp <- as.data.frame(cbind(d, i, j, p_target, path_length, pl_l, pl_u, trial_time, tt_l, tt_u))
if (d == 0 & i == unique(df$temperature)[1] & j == unique(df$nu)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
head(df)
summary(df)
for (d in 0) {
if (d == 0) bias <- FALSE
else {
bias <- TRUE
if (d == 1) centre <- FALSE
else centre <- TRUE
}
suffix <- '_no_bias'
if (bias) {
if (centre) suffix <- '_bias_c'
else suffix <- '_bias_s'
}
## Load data
df <- read.csv(paste0('parameters_n', size, suffix, '.csv'))
head(df)
for (i in unique(df$temperature)) {
for (j in unique(df$nu)) {
tmp <- df[which(df$temperature == i & df$nu == j),]
if (bias) {
if (centre) p_target <- (length(which(tmp$target_reached == 1))) / dim(tmp)[1]
else p_target <- (length(which(tmp$target_reached == 0))) / dim(tmp)[1]
} else p_target <- (length(which(tmp$target_reached == 0)) + length(which(tmp$target_reached == 2))) / (2*dim(tmp)[1])
path_length <- median(tmp$path_length)
pl_l <- quantile(tmp$path_length, 0.25)
pl_u <- quantile(tmp$path_length, 0.75)
trial_time <- median(tmp$trial_time)
tt_l <- quantile(tmp$trial_time, 0.25)
tt_u <- quantile(tmp$trial_time, 0.75)
tmp <- as.data.frame(cbind(d, i, j, p_target, path_length, pl_l, pl_u, trial_time, tt_l, tt_u))
if (d == 0 & i == unique(df$temperature)[1] & j == unique(df$nu)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
}
names(data) <- c("idx", "temperature", "nu", "p_target", "path_length", "pl_l", "pl_u", "trial_time", "tt_l", "tt_u")
data <- data[which(data$nu %% 0.04 == 0),]
data2 <- data[which(data$temperature == 0.02),]
ggplot(data2, aes(x = nu, y = p_target, colour = as.factor(idx))) + geom_path(size = 3, lineend = 'round') +
geom_vline(aes(xintercept = 0.54), colour = 'black') + guides(colour = FALSE) +
geom_hline(aes(yintercept = 0.33), colour = 'black', linetype = 'dashed') +
scale_colour_viv(discrete = TRUE, palette = 'asymmetric') +
xlab("Nu") + ylab("P(reaching the correct target)") + theme_cus()
ggplot(data2, aes(x = nu, y = path_length)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = pl_l, ymax = pl_u), alpha = 0.2) +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
ggplot(data2, aes(x = nu, y = trial_time)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = tt_l, ymax = tt_u), alpha = 0.2) +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
ggplot(data2, aes(x = nu, y = path_length)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = pl_l, ymax = pl_u), alpha = 0.2) + xlab("Nu") + ylab("Path length") +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
ggplot(data2, aes(x = nu, y = trial_time)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = tt_l, ymax = tt_u), alpha = 0.2) + xlab("Nu") + ylab("Time to target") +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
ggplot(data2, aes(x = nu, y = trial_time)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = tt_l, ymax = tt_u), alpha = 0.2) + xlab("Nu") + ylab("Time to target") +
geom_vline(aes(xintercept = 0.5), colour = 'black', linetype = 'dashed') + theme_cus()
ggsave(paste0('/Users/vivekhsridhar/Documents/Work/Ideas/Decision\ Geometry/Figures/McDonnell\ proposal/trail_time.png'),
width = 5, height = 5, dpi = 300)
ggplot(data2, aes(x = nu, y = trial_time)) + geom_path(size = 1, lineend = 'round') +
geom_ribbon(aes(ymin = tt_l, ymax = tt_u), alpha = 0.2) + xlab("Nu") + ylab("Time to target") +
geom_vline(aes(xintercept = 0.54), colour = 'black') + theme_cus()
ggsave(paste0('/Users/vivekhsridhar/Documents/Work/Ideas/Decision\ Geometry/Figures/McDonnell\ proposal/trail_time.png'),
width = 5, height = 5, dpi = 300)
