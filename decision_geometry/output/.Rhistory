#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 36
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 26
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 40
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output/")
dir <- getwd()
## Load data
df <- read.csv("geometry.csv")
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 2
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 3
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 3
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 3
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 3
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
## Parameters
N <- 2
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 2
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
## Load data
df <- read.csv("geometry.csv")
head(df)
ggplot(df, aes(x = x, y = y)) + geom_point(size = 1, alpha = 0.01) +
facet_grid(inhibition ~ .) + theme_cus()
## Load data
df <- read.csv("cue_reached.csv")
head(df)
## Parameters
N <- 2
if (N == 2) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
} else if (N == 3) {
for (i in unique(df$inhibition)) {
tmp = df[which(df$inhibition == i),]
p_target <- length(which(tmp$target_reached == 0)) / dim(tmp)[1]
path_length <- median(tmp$path_length)
tmp2 <- as.data.frame(cbind(i, p_target, path_length))
if (i == unique(df$inhibition)[1]) {
data <- tmp2
}
else {
data <- rbind(data, tmp2)
}
}
}
ggplot(data, aes(x = i, y = p_target)) + geom_point(size = 2) + theme_cus()
