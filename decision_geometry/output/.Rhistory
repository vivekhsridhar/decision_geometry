y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
event.id <- 40
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
event.id <- 33
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
event.id <- 34
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
rm(list = ls())
library(viridis)
library(reshape2)
library(ggplot2)
load('~/Dropbox/SHARED_Project_Collective decision updating/Data/sheep_group_events_all.RData')
load('~/Dropbox/SHARED_Project_Collective decision updating/Data/sheep_xy_interpolated.RData')
events.group.all <- events.group.all[order(events.group.all$t.start),]
events <- events.group.all[which(events.group.all$leave.patch.ID==11  & events.group.all$arrive.patch.ID %in% c(1,2,3,4,5)),]
event.id <- 34
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 33
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 36
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 26
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
event.id <- 40
dt <- 10 #time step for computing speed
sheep <- events$sheep.IDs[event.id][[1]]
t0 <- events$t.start[event.id]
tf <- events$turning.point[event.id]
n.inds <- length(sheep)
n.times <- tf-t0+1
arrival.patch <- events$arrive.patch.ID[event.id]
#get trajectories for sheep in event
x <- xs[sheep,t0:tf]
y <- ys[sheep,t0:tf]
t <- ts[t0:tf]
t.elapse <- t-min(t)
#get centroid
centr.x <- colMeans(x,na.rm=T)
centr.y <- colMeans(y,na.rm=T)
#get centroid speed (forwards in time)
t.idxs <- (1+dt):length(centr.x)
vx.centr <- c(centr.x[t.idxs] - centr.x[t.idxs-dt],rep(NA,dt))
vy.centr <- c(centr.y[t.idxs] - centr.y[t.idxs-dt],rep(NA,dt))
speed.centr <- sqrt(vx.centr^2 + vy.centr^2) / (dt*6)
#get centroid heading
source('/Users/vivekhsridhar/Dropbox/SHARED_Project_Collective\ decision\ updating/Analysis/Collective\ decision\ updating/spatially_discretized_headings.R')
centr.head <- spatial.headings(centr.x, centr.y, 5, backward = T)
#get x and y component of centroid direction
ux.centr <- cos(centr.head)
uy.centr <- sin(centr.head)
#headings and speeds for all individuals (forward in time)
vx <- cbind(x[,t.idxs] - x[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
vy <- cbind(y[,t.idxs] - y[,t.idxs-dt],matrix(NA,nrow=n.inds,ncol=dt))
speeds <- sqrt(vx^2+vy^2)/(dt*6)
heads <- matrix(NA, nrow=dim(x)[1], ncol=dim(x)[2])
for (ind in 1:n.inds) {
heads[ind,] <- spatial.headings(x[ind,], y[ind,], 5)
}
ux <- cos(heads)
uy <- sin(heads)
#get angle between centroid heading and individual heading
centr.head.mat <- matrix(rep(centr.head,each=n.inds),nrow=n.inds,ncol=n.times)
diff.angs <- heads - centr.head.mat
#wrap around between -pi and pi
diff.angs[which(diff.angs > pi)] <- diff.angs[which(diff.angs > pi)] - 2*pi
diff.angs[which(diff.angs < -pi)] <- diff.angs[which(diff.angs < -pi)] + 2*pi
#rms angle relative to centroid direction
rms.angs <- apply(diff.angs,2,function(x){return(sqrt(mean(x^2,na.rm=T)))})
rms.thresh <- 0.8
par(mfrow=c(2,1))
plot(t.elapse/60,speed.centr,type='l')
abline(h = 1/3.6, lty = 'dashed', col = 'red')
plot(t.elapse/60,rms.angs,type='l',ylim=c(0,pi))
par(mfrow=c(1,1))
hist(speeds, breaks = 50)
rm(list = ls())
## Load packages
library(reshape2)
library(ggplot2)
library(ggforce)
theme_cus <- function(base_size = 12, base_family = "Helvetica"){
theme_classic(base_size = base_size, base_family = base_family) +
theme(axis.title.x = element_text(size = 15, margin = margin(15,0,0,0)),
axis.title.y = element_text(size = 15, margin = margin(0,15,0,0)),
axis.text = element_text(size = 12),
axis.ticks.length = unit(0.3, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="right",
legend.background = element_rect(colour = "black"),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5))
}
## Set working directory
setwd("/Users/vivekhsridhar/Documents/Code/decision_geometry/decision_geometry/output/")
dir <- getwd()
## Set parameters
size <- '30'
bias <- FALSE
suffix <- '_no_bias'
if (bias) suffix <- '_bias'
## Load data
df <- read.csv(paste0('parameters_n', size, suffix, '.csv'))
head(df)
for (i in unique(df$temperature)) {
for (j in unique(df$nu)) {
tmp <- df[which(df$temperature == i & df$nu == j),]
if (bias) p_target <- (length(which(tmp$target_reached == 0))) / dim(tmp)[1]
else p_target <- (length(which(tmp$target_reached == 0)) + length(which(tmp$target_reached == 2))) / (2*dim(tmp)[1])
tmp <- as.data.frame(cbind(i, j, p_target))
if (i == unique(df$temperature)[1] & j == unique(df$nu)[1]) {
data <- tmp
}
else {
data <- rbind(data, tmp)
}
}
}
names(data) <- c("temperature", "nu", "p_target")
data$diff <- abs(data$p_target - 0.33)
data2 <- data[which(data$temperature == 0.1),]
ggplot(data, aes(x = temperature, y = p_target, colour = as.factor(nu))) + geom_path(size = 1, lineend = 'round') +
geom_hline(aes(yintercept = 0.33), colour = 'black') +
geom_vline(aes(xintercept = 0.1), colour = 'black', linetype = 'dashed') +
scale_colour_viridis_d() + theme_cus()
ggplot(data2, aes(x = nu, y = p_target)) + geom_path(size = 1, lineend = 'round') +
geom_hline(aes(yintercept = 0.33), colour = 'black') + theme_cus()
